/* Shared Use License: This file is owned by Derivative Inc. (Derivative) and
* can only be used, and/or modified for use, in conjunction with
* Derivative's TouchDesigner software, and only if you are a licensee who has
* accepted Derivative's TouchDesigner license or assignment agreement (which
* also govern the use of this file).  You may share a modified version of this
* file with another authorized licensee of Derivative's TouchDesigner software.
* Otherwise, no redistribution or sharing of this file, with or without
* modification, is permitted.
*/

/*
* Produced by:
*
* 				Derivative Inc
*				401 Richmond Street West, Unit 386
*				Toronto, Ontario
*				Canada   M5V 3A8
*				416-591-3555
*
* NAME:				SOP_CPlusPlusBase.h
*
*
*	Do not edit this file directly!
*	Make a subclass of SOP_CPlusPlusBase instead, and add your own
*	data/functions.

*	Derivative Developers:: Make sure the virtual function order
*	stays the same, otherwise changes won't be backwards compatible
*/
//#pragma once

#ifndef __SOP_CPlusPlusBase__
#define __SOP_CPlusPlusBase__

#include "CPlusPlus_Common.h"

#define SOP_CPLUSPLUS_API_VERSION	1

class SOP_CPlusPlusBase;


// These are the definitions for the C-functions that are used to
// load the library and create instances of the object you define
typedef int32_t(__cdecl *GETSOPAPIVERSION)(void);
typedef SOP_CPlusPlusBase* (__cdecl *CREATESOPINSTANCE)(const OP_NodeInfo*);
typedef void(__cdecl *DESTROYSOPINSTANCE)(SOP_CPlusPlusBase*);


class SOP_GeneralInfo
{
public:
	// Set this to true if you want the SOP to cook every frame, even
	// if none of it's inputs/parameters are changing
	// DEFAULT: false

	bool	cookEveryFrame;

	// Set this to true if you want the SOP to cook every frame, but only
	// if someone asks for it to cook. So if nobody is using the output from
	// the SOP, it won't cook. This is difereent from 'cookEveryFrame'
	// since that will cause it to cook every frame no matter what.

	bool	cookEveryFrameIfAsked;


	// set this flag to true to load the geometry to the GPU for faster updating
	// Note that if you set this flag to 'true', then the function executeVBO() is being called
	// instead of execute() function. Therefore, you must call the functions from SOP_VBOOutput
	// to fill the VBO buffers.
	// If this flag is set to false, then execute() function is being called and
	// you must call the functions from SOP_Output class instead of SOP_VBOOutput
	// to add the geometry data from your source/algorithm.

	bool	directToGPU;


private:

	int32_t	reserved[20];
};



// the buffer object mode:
enum  class VBOBufferMode : int32_t
{
	Static = 0,  //The data will be modified once and used many times
	Dynamic,     //The data will be modified repeatedly and used many times
};


// CPU loading of geometry:
// NOTE: set 'directToGPU' flag from SOP_GeneralInfo class to false.

class SOP_Output
{
public:

	SOP_Output()
	{
	}

	~SOP_Output()
	{
	}


	// add and set an array of float points array of pt.
	// The pt array holds the sequence of x, y, and z of input points.
	// i.e. the xi, yi, and zi values for the i-th point/vertex of the geometry.
	// the input param 'size' represents the number of points to be added. The pt array must have
	// size*3 values. The function or addPoint() must be called first.

	virtual void	addPoints(const float *pt, int32_t size) = 0;

	// add and set one point at a time with x,y,z values.

	virtual int32_t	addPoint(float x, float y, float z) = 0;

	// set the normal vector for the point with the 'pointIdx' as the index of the point
	// that has been ALREADY added by getPoints() or getPoint().

	virtual void	setNormal(float x, float y, float z, int32_t pointIdx) = 0;

	// set the sequence normal vectors with x,y,z values.
	// Note that has been the points must be ALREADY added by calling getPoints() or getPoint().
	// the size param is the number of normals.
	// the startPointIdx indicates the start index of the points.

	virtual bool	setNormals(const float *nt, int32_t size, int32_t startPointIdx) = 0;

	// set the color value with r,g,b,a (for RGBA) for the point with 'pointIdx' index.

	virtual void	setColor(float r, float g, float b, float a, int32_t pointIdx) = 0;

	// set the sequnece of input colors for points that are already added.
	// each color must hold 4 values.
	// the size param is the number of color.
	// the startPointIdx indicates the start index of the points.

	virtual bool	setColors(const float *c, int32_t size, int32_t startPointIdx) = 0;


	// set the custom attribute with it's name, number of components, and it's type
	// the data param must holds the data for the custom attribute.
	// e.g a custom atrrib with 4 components for each point should holds 4*numVertices values.

	virtual void	setCustomAttribute(const char *name, int32_t numComp, AttribType type, const void *data, int32_t numVertices) = 0;

	// set texture with input data t, the t has 3*texSize floats for each point,
	// the texSize is the texture size and can be from 1 up to 8 for texture layers
	// the pointIdx specifies the point index with the texture coords

	virtual void	setTexture(const float *t, int32_t texSize, int32_t pointIdx) = 0;

	// add three indices of the points for creating a triangle

	virtual void	addTriangle(int32_t ptid1, int32_t ptid2, int32_t ptid3) = 0;

	// add an array of point's indices, if no input array is specified it will return false.
	// the size param represents the number of triangles to be added.

	virtual bool	addTriangles(const int32_t *ptid, int32_t size) = 0;

	// add particle systems from the points that has been already added. The points can have colors, normals and custom attribs.
	// the startIndex param is the staring index of the points from particle system.

	virtual void	addParticleSystem(int32_t numParticles, int32_t startIndex) = 0;


private:

	int32_t    reserved[20];
};


// loading data straight to the GPU
// NOTE: set 'directToGPU' flag from SOP_GeneralInfo class to true.

class SOP_VBOOutput
{

public:

	SOP_VBOOutput()
	{
	}


	~SOP_VBOOutput()
	{
	}

	// enable/set the normal and color in case the geometry contains these information

	virtual void	enableNormal() = 0;

	virtual void	enableColor() = 0;

	virtual bool	hasNormal() = 0;

	virtual bool	hasColor() = 0;

	// add the custom attribute with it's name, number of components, and it's type.
	//  Make sure that the attribute type ID's remain constant from compile
	//	to compile since they are saved with the detail.

	virtual void	addCustomAttribute(char *name, int32_t numComp, AttribType type) = 0;

	// allocates and setup VBO buffers. Call this fucntion before adding any points, colors or normals,
	// but after addCustomAttribute().

	virtual void	allocVBO(int32_t numVertices, int32_t numIndices, VBOBufferMode mode) = 0;

	// returns the start of the pointer array for the points to be set

	virtual float*	getPos() = 0;

	// returns the start of the pointer array for the normals to be set

	virtual float*	getNormals() = 0;

	// returns the start of the pointer array for the colors to be set

	virtual float*	getColors() = 0;

	//  returns the start of the pointer array for the triangles to be set.

	virtual int32_t*	getTriangles(int32_t numTriangles) = 0;

	// returns the start of the pointer array for the custom attributes by its name that has been ALREADY specified.

	virtual float*	getCustomAttribute(char *name) = 0;

	// update the VBO buffers:
	// after you are done with the VBO buffers, make sure to call this function
	// Note: this function must be the last function to be called.

	virtual void	updateComplete() = 0;


private:

};



/*** DO NOT EDIT THIS CLASS, MAKE A SUBCLASS OF IT INSTEAD ***/
class SOP_CPlusPlusBase
{

protected:

	SOP_CPlusPlusBase()
	{
	}

public:

	virtual
	~SOP_CPlusPlusBase()
	{
	}

	// BEGIN PUBLIC INTERFACE

	// Some general settings can be assigned here (if you ovierride it)

	virtual void
	getGeneralInfo(SOP_GeneralInfo*)
	{
	}


	// Add geometry data such as points, normals, colors, and triangles
	// or particles and etc. obtained from your desired algorithm or external files.
	// If the "directToGPU" flag is set to false, this function is being called
	// instead of executeVBO().
	// See the OP_Inputs class definition for more details on it's contents

	virtual void	execute(SOP_Output*, OP_Inputs*, void* reserved) = 0;

	// for direct GPU loading (i.e "directToGPU" is set to true) this function is being called
	// instead of execute().
	// fill the VBO buffers with the geometry data, obtained from your desired algorithm or files,
	// such as points, normals, colors, textures, triangles, and etc.

	virtual void	executeVBO(SOP_VBOOutput*, OP_Inputs*, void* reserved) = 0;


	// Override these methods if you want to output values to the Info CHOP/DAT
	// returning 0 means you dont plan to output any Info CHOP channels

	virtual int32_t
	getNumInfoCHOPChans()
	{
		return 0;
	}

	// Specify the name and value for CHOP 'index',
	// by assigning something to 'name' and 'value' members of the
	// OP_InfoCHOPChan class pointer that is passed (it points
	// to a valid instance of the class already.
	// the 'name' pointer will initially point to nullptr
	// you must allocate memory or assign a constant string
	// to it.

	virtual void
	getInfoCHOPChan(int32_t index,OP_InfoCHOPChan* chan)
	{
	}


	// Return false if you arn't returning data for an Info DAT
	// Return true if you are.
	// Set the members of the CHOP_InfoDATSize class to specify
	// the dimensions of the Info DAT
	virtual bool
	getInfoDATSize(OP_InfoDATSize* infoSize)
	{
		return false;
	}


	// You are asked to assign values to the Info DAT 1 row or column at a time
	// The 'byColumn' variable in 'getInfoDATSize' is how you specify
	// if it is by column or by row.
	// 'index' is the row/column index
	// 'nEntries' is the number of entries in the row/column

	virtual void
	getInfoDATEntries(int32_t index, int32_t nEntries, OP_InfoDATEntries* entries)
	{
	}


	// You can use this function to put the node into a warning state
	// with the returned string as the message.
	// Return nullptr if you don't want it to be in a warning state.
	virtual const char*
	getWarningString()
	{
		return nullptr;
	}

	// You can use this function to put the node into a error state
	// with the returned string as the message.
	// Return nullptr if you don't want it to be in a error state.
	virtual const char*
	getErrorString()
	{
		return nullptr;
	}

	// Use this function to return some text that will show up in the
	// info popup (when you middle click on a node)
	// Return nullptr if you don't want to return anything.
	virtual const char*
	getInfoPopupString()
	{
		return nullptr;
	}


	// Override these methods if you want to define specfic parameters
	virtual void
	setupParameters(OP_ParameterManager* manager)
	{
	}


	// This is called whenever a pulse parameter is pressed
	virtual void
	pulsePressed(const char* name)
	{
	}

	// END PUBLIC INTERFACE


private:

	// Reserved for future features
	virtual int32_t	reservedFunc6() { return 0; }
	virtual int32_t	reservedFunc7() { return 0; }
	virtual int32_t	reservedFunc8() { return 0; }
	virtual int32_t	reservedFunc9() { return 0; }
	virtual int32_t	reservedFunc10() { return 0; }
	virtual int32_t	reservedFunc11() { return 0; }
	virtual int32_t	reservedFunc12() { return 0; }
	virtual int32_t	reservedFunc13() { return 0; }
	virtual int32_t	reservedFunc14() { return 0; }
	virtual int32_t	reservedFunc15() { return 0; }
	virtual int32_t	reservedFunc16() { return 0; }
	virtual int32_t	reservedFunc17() { return 0; }
	virtual int32_t	reservedFunc18() { return 0; }
	virtual int32_t	reservedFunc19() { return 0; }
	virtual int32_t	reservedFunc20() { return 0; }

	int32_t			reserved[400];

};

#endif
